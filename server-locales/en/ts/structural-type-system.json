{
  "structuralTypeSystem": {
    "title": "The Structural Type System",

    "gettingStarted": {
      "p1": "<span>If you’ve worked with several programming languages — including <strong>JavaScript</strong> — you’ve probably noticed how different it is from most of them. It’s more <strong>flexible</strong> and <strong>dynamic</strong>, and doesn’t restrict you with as many strict rules as other languages do.</span>",
      "p2": "<span>But that flexibility opens the door to more potential errors and unexpected code behavior. Many developers, especially beginners, find that <strong>JavaScript</strong> sometimes behaves in surprising ways. It’s not that the language is broken — it’s simply built on <strong>dynamic rules</strong> that aren’t always obvious at first.</span>",
      "p3": "<span>This led to the need for a stricter form of <strong>type control</strong> in <strong>JavaScript</strong>, to enable <strong>type checking</strong> before running the code. That’s where <strong>TypeScript</strong> came in — introducing a powerful <strong>type system</strong> built on top of <strong>JavaScript</strong>.</span>",
      "p4": "<span>Before diving deeper, let’s ask a few related questions:</span>",
      "questions": {
        "q1": "<span>What exactly is a <strong>Type</strong>?</span>",
        "q2": "<span>What is a <strong>Type System</strong>, and what role does it play?</span>",
        "q3": "<span>How does <strong>JavaScript’s dynamic nature</strong> relate to the confusing behavior many developers encounter?</span>",
        "q4": "<span>And Why did <strong>TypeScript</strong> choose to rely on a <strong>Structural Type System</strong> specifically?</span>"
      }
    },

    "whatIsType": {
      "title": "What Is a Type?",
      "p1": "<span>In programming, a <strong>Type</strong> simply represents the kind of data a variable holds.</span>",
      "p2": "<span>For instance, if a variable is of type <strong>Number</strong>, it means it’s expected to store numeric values only — not <strong>strings</strong> or other data types.</span>",
      "p3": "<span>Different programming languages provide different built-in <strong>types</strong>, and some allow you to define your own <strong>custom types</strong> that combine multiple shapes or data kinds into a single <strong>Type</strong>.</span>",
      "p4": "<span>This is where the <strong>Type System</strong> comes in — it defines how these types interact and ensures logical consistency in your code.</span>"
    },

    "whatIsTypeSystem": {
      "title": "What Is a Type System?",
      "p1": "<span>Every programming language comes with its own set of <strong>types</strong> and rules that define how they interact — specifying what operations are valid for each type and which combinations would cause errors.</span>",
      "p2": "<span>These rules prevent illogical operations, like adding a string to a number, which would otherwise result in a <strong>code error</strong>.</span>",
      "p3": "<span>However, not all languages enforce these rules equally. In flexible languages like <strong>JavaScript</strong>, you can combine different types thanks to a feature called <strong>Type Coercion</strong>, where the engine automatically converts one operand to a compatible type — e.g., turning a number into a string when concatenating.</span>",
      "p4": "<span>Other languages, like <strong>Python</strong>, are stricter and won’t allow this without explicit conversion. Otherwise, they’ll throw a <strong>Type Error</strong>.</span>",
      "p5": "<span>And this leads us to the next point: why we describe <strong>JavaScript</strong> as a <strong>weakly typed dynamic language</strong>.</span>"
    },

    "whyJsDynamic": {
      "title": "Why Is JavaScript a Weakly Typed Dynamic Language?",
      "p1": "<span><strong>JavaScript</strong> is considered a <strong>dynamic language</strong> because variables can hold values of different types during <strong>runtime</strong>. For example, a variable that starts as a <strong>number</strong> can later store a <strong>string</strong> or even an <strong>array</strong>.</span>",
      "code1": {
        "line1": "let x = 5; // numeric value",
        "line2": "x = \"Hello\"; // string value",
        "line3": "let x = [1,2]; // Array"
      },
      "p2": "<span>It's also <strong>weakly typed</strong> because it allows operations between incompatible types without manual conversion. The engine automatically performs <strong>implicit type coercion</strong> based on internal rules to make the operation valid.</span>",
      "code2": {
        "line1": "let num = 5; // numeric value",
        "line2": "let str = \"10\" // string value",
        "line3": "let result = num + str; // Implicit Coercion",
        "line4": "console.log(result); // Output: \"510\""
      },
      "code3": {
        "line1": "let num = 2; // numeric value",
        "line2": "let bool = true; // boolean value",
        "line3": "let result = bool + num; // Implicit Coercion",
        "line4": "console.log(result); // Output: 3"
      },
      "p3": "<span>This flexibility, while convenient, can lead to unpredictable code behavior and subtle bugs — which is why <strong>TypeScript</strong> was created: to add type safety while keeping JavaScript's dynamic nature.</span>",
      "p4": "<span>To achieve that balance, <strong>TypeScript</strong> adopted a <strong>Structural Type System</strong>.</span>"
    },

    "whatIsStructuralTypeSystem": {
      "title": "What Is the Structural Type System — and Why Does TypeScript Use It?",
      "p1": "<span>The <strong>Structural Type System</strong> determines type compatibility based on structure, not on names or inheritance. If two types have the same <strong>Properties</strong> and internal shapes, they’re considered compatible — even if they come from different <strong>interfaces</strong> or <strong>classes</strong>.</span>",
      "p2": "<span>In short: it cares about <strong>shape</strong>, not <strong>name</strong>.</span>",
      "p3": "<span><strong>TypeScript</strong> uses this approach because it was designed to work seamlessly with <strong>JavaScript</strong>, where anonymous objects and function expressions are common. A structural system allows this kind of flexibility.</span>",
      "p4": "<span>The key principles of structural typing can be summarized in three main ideas:</span>",
      "principles": {
        "shape": "<span><strong>Shape Compatibility:</strong> Two types are compatible if their properties share the same structure.</span>",
        "extra": "<span><strong>Extra Properties Are Allowed:</strong> Objects can include additional properties beyond those defined in the type, as long as the required shape is present.</span>",
        "functions": "<span><strong>Parameter Bivariance:</strong> Functions can still be compatible even if their parameter types differ slightly, as long as the overall function signature matches.</span>"
      },
      "example1": {
        "title": "Example 1: Same Properties",
        "code": "interface Point {\n  x: number;\n  y: number;\n}\n\ninterface Coordinates {\n  x: number;\n  y: number;\n}\n\nlet p: Point = { x: 10, y: 20 };\nlet c: Coordinates = p;",
        "explanation": "X and Y compatibility is allowed because the shape matches."
      },
      "example2": {
        "title": "Example 2: Adding Extra Properties",
        "code": "interface Person {\n  name: string;\n}\n\nlet user = { name: \"Ahmed\", age: 25 };\n\nlet p: Person = user;",
        "explanation": "user has an extra age property, but structural typing cares about the minimum required (basic shape)."
      },
      "example3": {
        "title": "Example 3: Function Compatibility",
        "code": "type Logger = (msg: string) => void;\n\nfunction logMessage(fn: Logger) {\n  fn(\"Hello\");\n}\n\nfunction customLogger(message: string) {\n  console.log(\"Log:\", message);\n}\n\nlogMessage(customLogger); // ✅",
        "explanation": "The customLogger function has the same signature as Logger, even if the parameter name is different  it's fine, the important thing is that the shape matches."
      },
      "example4": {
        "title": "Example 4: Partial Matching",
        "code": "interface Animal {\n  name: string;\n}\n\nlet dog = { name: \"Rex\", breed: \"German Shepherd\" };\n\nlet a: Animal = dog; // ✅ works",
        "explanation": "Here dog has more properties (breed), but since it contains name, it works with Animal."
      }
    },

    "nominalVsStructural": {
      "title": "Structural vs. Nominal Typing",
      "p1": "<span>While <strong>Structural Typing</strong> fits naturally with <strong>TypeScript’s</strong> design, it’s not the only approach. Many other languages use a different model known as the <strong>Nominal Type System</strong>.</span>",
      "p2": "<span>In a <strong>Nominal System</strong>, type compatibility is determined by explicit names or declared relationships (like inheritance). Even if two types share the same properties, they're not considered the same unless they share a name or hierarchy. This makes type checking stricter and safer but less flexible.</span>",
      "code": "\"Example in Python\"\n\nclass USD:\n    def __init__(self, value: float):\n        self.value = value\n\nclass EGP:\n    def __init__(self, value: float):\n        self.value = value\n\n\"Variable of type USD\"\namount_in_usd = USD(100)\n\n\"Variable of type EGP\"\namount_in_egp = EGP(100)\n\n\"✅ Valid and allowed - same type\"\nsame_currency: USD = amount_in_usd\n\n\"❌ Not allowed - different types by name despite identical structure\"\nwrong_currency: USD = amount_in_egp  # Error in Nominal Typing system",
      "p3": "<span>That's why <strong>TypeScript</strong> chose the structural approach — it provides flexibility while keeping JavaScript's natural behavior, but with more safety and predictability.</span>",
      "p4": "<span>Of course, this comes with trade-offs. Let's explore its main strengths and limitations next.</span>"
    },

    "advantages": {
      "title": "Advantages of the Structural Type System",
      "flexibility": "<span><strong>Flexibility:</strong> Enables smooth interaction between different types that share similar structures, without requiring identical names.</span>",
      "boilerplate": "<span><strong>Reduced Boilerplate:</strong> Since compatibility is based on shape, you don’t need to define redundant or duplicate types.</span>",
      "reusability": "<span><strong>Reusability:</strong> Types can be reused across different contexts as long as their shapes match.</span>",
      "compatibility": "<span><strong>JavaScript Compatibility:</strong> Perfectly aligns with JavaScript’s dynamic nature, allowing easy integration with existing JavaScript projects.</span>",
      "note": "<span>However, while <strong>TypeScript’s structural typing</strong> offers great flexibility, it also introduces some challenges that developers need to be aware of.</span>"
    },

    "limitations": {
      "title": "Limitations of the Structural Type System",
      "unintended": "<span><strong>Unintended Compatibility:</strong> Two types may match in structure but differ in meaning or intent, potentially leading to logical errors.</span>",
      "safety": "<span><strong>Safety vs. Flexibility:</strong> The system’s flexibility can sometimes compromise type safety if not used carefully.</span>",
      "reflection": "<span><strong>Lack of Reflection:</strong> Type checking occurs only at <strong>compile time</strong>, not <strong>runtime</strong>, which limits dynamic type introspection.</span>",
      "debugging": "<span><strong>Debugging Difficulty:</strong> Since compatibility is implicit, logical mismatches can slip through unnoticed and make debugging harder.</span>"
    },

    "relatedQuestions": {
      "q1": "How do different languages handle custom types?",
      "q2": "Could JavaScript ever support a form of static typing natively?",
      "q3": "What are all the coercion rules in JavaScript?",
      "q4": "Is it possible to mix Structural and Nominal systems in the same project?",
      "q5": "Are there languages that combine both Nominal and Structural typing?",
      "q6": "Is it possible to simulate Nominal Typing in TypeScript using any trick or workaround?"
    }
  }
}
